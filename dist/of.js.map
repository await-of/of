{"version":3,"file":"of.js","sources":["../src/const/error.mjs","../src/core/of.mjs","../src/core/ofAny.mjs","../src/const/type.mjs","../src/core/ofAnyCase.mjs","../src/core/ofCase.mjs","../src/core/ofError.mjs","../src/core/ofIt.mjs","../src/core/ofOutcome.mjs","../src/core/ofResult.mjs","../src/core/ofSync.mjs","../src/util/isFunction.mjs","../src/index.mjs"],"sourcesContent":["export const ERR_UNKNOWN = \"Unknown Error\";\n","import { ERR_UNKNOWN } from \"../const/error.mjs\";\n\n/**\n * @name of\n * @param {Promise} promise\n * @returns {Promise<[*, unknown] | [undefined, *]>}\n */\nexport function of(promise) {\n  return Promise.resolve(promise)\n    .then((result) => [result])\n    .catch((caughtError) => {\n      if (caughtError === undefined || caughtError === null) {\n        caughtError = new Error(ERR_UNKNOWN);\n      }\n      return [undefined, caughtError];\n    });\n}\n","import { ERR_UNKNOWN } from \"../const/error.mjs\";\nimport { FUNC, FUNC_ASYNC, FUNC_GEN, OBJ_GEN, PROMISE } from \"../const/type.mjs\";\n\n/**\n * @name ofAny\n * @param {Function|Promise} callable\n * @param {[]=} args\n * @param {*=} defaultResult\n * @param {*=} overrideError\n * @returns {Promise<[*, unknown] | [undefined, *]>}\n */\nexport function ofAny(callable, args, defaultResult, overrideError) {\n  let call;\n  switch (callable.constructor.name || Object.prototype.toString.call(callable)) {\n    case PROMISE:\n      call = callable;\n      break;\n    case FUNC_ASYNC:\n      call = callable(...(Array.isArray(args) ? [...args] : []));\n      break;\n    case FUNC:\n      call = new Promise((resolve, reject) => {\n        try {\n          resolve(callable(...(Array.isArray(args) ? [...args] : [])));\n        } catch (caughtFunctionError) {\n          reject(caughtFunctionError);\n        }\n      });\n      break;\n    case FUNC_GEN:\n      call = new Promise((resolve, reject) => {\n        const gen = callable(...(Array.isArray(args) ? [...args] : []));\n        try {\n          resolve(gen.next().value);\n        } catch (caughtGeneratorFunctionError) {\n          reject(caughtGeneratorFunctionError);\n        }\n      });\n      break;\n    case OBJ_GEN:\n      call = new Promise((resolve, reject) => {\n        try {\n          resolve(callable.next().value);\n        } catch (caughtGeneratorError) {\n          reject(caughtGeneratorError);\n        }\n      });\n      break;\n    default:\n      call = new Promise((resolve, reject) => {\n        Promise.resolve(callable).then(resolve).catch(reject);\n      });\n  }\n  return Promise.resolve(call)\n    .then((result) => [result])\n    .catch((caughtError) => {\n      if (caughtError === undefined || caughtError === null) {\n        caughtError = new Error(ERR_UNKNOWN);\n      }\n      if (overrideError instanceof Error) {\n        caughtError = overrideError;\n      } else if (typeof overrideError === \"string\") {\n        caughtError.message = overrideError;\n      }\n      return [defaultResult, caughtError];\n    });\n}\n","export const FUNC = \"Function\";\nexport const FUNC_ASYNC = \"AsyncFunction\";\nexport const FUNC_GEN = \"GeneratorFunction\";\nexport const OBJ_GEN = \"[object Generator]\";\nexport const PROMISE = \"Promise\";\n","import { ERR_UNKNOWN } from \"../const/error.mjs\";\nimport { FUNC, FUNC_ASYNC, FUNC_GEN, OBJ_GEN, PROMISE } from \"../const/type.mjs\";\n\n/**\n * @name ofAnyCase\n * @param {Function|Promise} callable\n * @param {*=} config\n * @returns {Promise<[*, unknown] | [undefined, *]>}\n */\nexport function ofAnyCase(callable, config = {}) {\n  {\n    const { args, defaults, error, retries, timeout } = new Object(config);\n    config = { args, defaults, error, retries, timeout };\n  }\n  let call;\n  switch (callable.constructor.name || Object.prototype.toString.call(callable)) {\n    case PROMISE:\n      call = callable;\n      config.retries = 0;\n      delete config.args;\n      break;\n    case FUNC_ASYNC:\n      call = callable(...(Array.isArray(config.args) ? [...config.args] : []));\n      break;\n    case FUNC:\n      call = new Promise((resolve, reject) => {\n        try {\n          resolve(callable(...(Array.isArray(config.args) ? [...config.args] : [])));\n        } catch (caughtFunctionError) {\n          reject(caughtFunctionError);\n        }\n      });\n      break;\n    case FUNC_GEN:\n      call = new Promise((resolve, reject) => {\n        const gen = callable(...(Array.isArray(config.args) ? [...config.args] : []));\n        try {\n          resolve(gen.next().value);\n        } catch (caughtGeneratorFunctionError) {\n          reject(caughtGeneratorFunctionError);\n        }\n      });\n      break;\n    case OBJ_GEN:\n      call = new Promise((resolve, reject) => {\n        try {\n          resolve(callable.next().value);\n        } catch (caughtGeneratorError) {\n          reject(caughtGeneratorError);\n        }\n      });\n      delete config.args;\n      break;\n    default:\n      call = new Promise((resolve, reject) => {\n        Promise.resolve(callable).then(resolve).catch(reject);\n      });\n      delete config.args;\n  }\n  if (config.timeout !== undefined) {\n    const timeout = Number.parseInt(`${config.timeout}`);\n    if (Number.isFinite(timeout) && timeout > 0) {\n      config.timeout = timeout > Number.MAX_SAFE_INTEGER ? Number.MAX_SAFE_INTEGER : timeout;\n    } else {\n      delete config.timeout;\n    }\n  } else {\n    delete config.timeout;\n  }\n  return (config.timeout\n    ? Promise.race([\n        Promise.resolve(call),\n        new Promise((_resolve, reject) => {\n          setTimeout(() => reject(new Error(`Timeout: ${config.timeout}ms`)));\n        }),\n      ])\n    : Promise.resolve(call)\n  )\n    .then((result) => [result])\n    .catch((caughtError) => {\n      if (config.retries !== undefined) {\n        const retries = Number.parseInt(config.retries);\n        if (Number.isFinite(retries) && retries > 0) {\n          config.retries = retries > Number.MAX_SAFE_INTEGER ? Number.MAX_SAFE_INTEGER : retries;\n        } else {\n          delete config.retries;\n        }\n      } else {\n        delete config.retries;\n      }\n      if (config.retries) {\n        config.attempt = config.attempt === undefined ? 0 : config.attempt + 1;\n        if (config.attempt < config.retries) {\n          return ofAnyCase(callable, config);\n        }\n      }\n      if (caughtError === undefined || caughtError === null) {\n        caughtError = new Error(ERR_UNKNOWN);\n      }\n      if (config.error instanceof Error) {\n        caughtError = config.error;\n      } else if (typeof config.error === \"string\") {\n        caughtError.message = config.error;\n      }\n      return [config.defaults, caughtError];\n    });\n}\n","import { ERR_UNKNOWN } from \"../const/error.mjs\";\n\n/**\n * @name ofCase\n * @param {Promise} promise\n * @param {*=} config\n * @returns {Promise<[*, unknown] | [undefined, *]>}\n */\nexport function ofCase(promise, config = {}) {\n  {\n    const { args, defaults, error, timeout } = new Object(config);\n    config = { args, defaults, error, timeout };\n  }\n  if (config.timeout !== undefined) {\n    const timeout = Number.parseInt(`${config.timeout}`);\n    if (Number.isFinite(timeout) && timeout > 0) {\n      config.timeout = timeout > Number.MAX_SAFE_INTEGER ? Number.MAX_SAFE_INTEGER : timeout;\n    } else {\n      delete config.timeout;\n    }\n  } else {\n    delete config.timeout;\n  }\n  return (config.timeout\n    ? Promise.race([\n        Promise.resolve(promise),\n        new Promise((_resolve, reject) => {\n          setTimeout(() => reject(new Error(`Timeout: ${config.timeout}ms`)));\n        }),\n      ])\n    : Promise.resolve(promise)\n  )\n    .then((result) => [result, undefined])\n    .catch((caughtError) => {\n      if (caughtError === undefined || caughtError === null) {\n        caughtError = new Error(ERR_UNKNOWN);\n      }\n      if (config.error instanceof Error) {\n        caughtError = config.error;\n      } else if (typeof config.error === \"string\") {\n        caughtError.message = config.error;\n      }\n      return [config.defaults, caughtError];\n    });\n}\n","import { ERR_UNKNOWN } from \"../const/error.mjs\";\n\n/**\n * @name ofError\n * @param {Promise} promise\n * @param {*=} overrideError\n * @returns {Promise<*>}\n */\nexport function ofError(promise, overrideError) {\n  return Promise.resolve(promise)\n    .then(() => undefined)\n    .catch((caughtError) => {\n      if (caughtError === undefined || caughtError === null) {\n        caughtError = new Error(ERR_UNKNOWN);\n      }\n      if (overrideError instanceof Error) {\n        caughtError = overrideError;\n      } else if (typeof overrideError === \"string\") {\n        caughtError.message = overrideError;\n      }\n      return caughtError;\n    });\n}\n","import { ERR_UNKNOWN } from \"../const/error.mjs\";\n\n/**\n * @name ofIt\n * @param {Promise} promise\n * @param {*=} defaultResult\n * @param {*=} overrideError\n * @returns {Promise<[*, unknown] | [undefined, *]>}\n */\nexport function ofIt(promise, defaultResult, overrideError) {\n  return Promise.resolve(promise)\n    .then((result) => [result])\n    .catch((caughtError) => {\n      if (caughtError === undefined || caughtError === null) {\n        caughtError = new Error(ERR_UNKNOWN);\n      }\n      if (overrideError instanceof Error) {\n        caughtError = overrideError;\n      } else if (typeof overrideError === \"string\") {\n        caughtError.message = overrideError;\n      }\n      return [defaultResult, caughtError];\n    });\n}\n","import { ofAnyCase } from \"./ofAnyCase.mjs\";\n\n/**\n * @name ofOutcome\n * @description Returns result or thrown error wherever happens\n * @param {Function|Promise} callable\n * @param {*=} config\n * @returns {Promise<*>}\n */\nexport function ofOutcome(callable, config = {}) {\n  return new Promise((resolve) =>\n    ofAnyCase(callable, config).then(([result, error]) => {\n      resolve(error ? error : result);\n    }),\n  );\n}\n","/**\n * @name ofResult\n * @param {Promise} promise\n * @param {*=} defaultResult\n * @returns {Promise<*>}\n */\nexport function ofResult(promise, defaultResult) {\n  return Promise.resolve(promise)\n    .then((result) => result)\n    .catch(() => defaultResult);\n}\n","import { ERR_UNKNOWN } from \"../const/error.mjs\";\n\nimport { isFunction } from \"../util/isFunction.mjs\";\n\n/**\n * @name ofSync\n * @param {Function} callable\n * @param {[]=} args\n * @param {*=} defaultResult\n * @param {*=} overrideError\n * @returns {[*, unknown] | [undefined, *]}\n */\nexport function ofSync(callable, args, defaultResult, overrideError) {\n  if (!isFunction(callable)) {\n    return [undefined, new Error(ERR_UNKNOWN)];\n  }\n  try {\n    return [callable(...(Array.isArray(args) ? [...args] : [])), undefined];\n  } catch (caughtFunctionError) {\n    let caughtError;\n    if (overrideError instanceof Error) {\n      caughtError = overrideError;\n    } else if (typeof overrideError === \"string\") {\n      caughtFunctionError.message = overrideError;\n      caughtError = caughtFunctionError;\n    } else if (caughtFunctionError === undefined || caughtFunctionError === null) {\n      caughtError = new Error(ERR_UNKNOWN);\n    } else {\n      caughtError = caughtFunctionError;\n    }\n    return [defaultResult, caughtError];\n  }\n}\n","/**\n * @param {*} value\n * @returns {boolean}\n */\nexport function isFunction(value) {\n  if (Object.prototype.toString.call(value) !== \"[object Function]\") {\n    return false;\n  }\n  return !/^class\\s/.test(Function.prototype.toString.call(value));\n}\n","import { of } from \"./core/of.mjs\";\nimport { ofAny } from \"./core/ofAny.mjs\";\nimport { ofAnyCase } from \"./core/ofAnyCase.mjs\";\nimport { ofCase } from \"./core/ofCase.mjs\";\nimport { ofError } from \"./core/ofError.mjs\";\nimport { ofIt } from \"./core/ofIt.mjs\";\nimport { ofOutcome } from \"./core/ofOutcome.mjs\";\nimport { ofResult } from \"./core/ofResult.mjs\";\nimport { ofSync } from \"./core/ofSync.mjs\";\n\nclass Of {\n  /**\n   * @name any\n   * @alias ofAny\n   * @public\n   * @static\n   * @method\n   * @param {Function|Promise} callable\n   * @param {[]=} args\n   * @param {*=} defaultResult\n   * @param {*=} overrideError\n   * @returns {Promise<[*, unknown] | [undefined, *]>}\n   */\n  static any = ofAny;\n  /**\n   * @name anyCase\n   * @alias ofAnyCase\n   * @public\n   * @static\n   * @method\n   * @param {Function|Promise} callable\n   * @param {*=} config\n   * @returns {Promise<[*, unknown] | [undefined, *]>}\n   */\n  static anyCase = ofAnyCase;\n  /**\n   * @name case\n   * @alias ofCase\n   * @public\n   * @static\n   * @method\n   * @param {Promise} promise\n   * @param {*=} config\n   * @returns {Promise<[*, unknown] | [undefined, *]>}\n   */\n  static case = ofCase;\n  /**\n   * @name error\n   * @alias ofError\n   * @public\n   * @static\n   * @method\n   * @param {Promise} promise\n   * @param {*=} overrideError\n   * @returns {Promise<*>}\n   */\n  static error = ofError;\n  /**\n   * @name it\n   * @alias ofIt\n   * @public\n   * @static\n   * @method\n   * @param {Promise} promise\n   * @param {*=} defaultResult\n   * @param {*=} overrideError\n   * @returns {Promise<[*, unknown] | [undefined, *]>}\n   */\n  static it = ofIt;\n  /**\n   * @name async\n   * @alias of\n   * @public\n   * @static\n   * @method\n   * @param {Promise} promise\n   * @returns {Promise<[*, unknown] | [undefined, *]>}\n   */\n  static async = of;\n  /**\n   * @name result\n   * @alias ofResult\n   * @public\n   * @static\n   * @method\n   * @param {Promise} promise\n   * @param {*=} defaultResult\n   * @returns {Promise<*>}\n   */\n  static result = ofResult;\n  /**\n   * @name sync\n   * @alias ofSync\n   * @public\n   * @static\n   * @method\n   * @param {Function} callable\n   * @param {[]=} args\n   * @param {*=} defaultResult\n   * @param {*=} overrideError\n   * @returns {[*, unknown] | [undefined, *]}\n   */\n  static sync = ofSync;\n  /**\n   * @name outcome\n   * @alias ofOutcome\n   * @public\n   * @static\n   * @method\n   * @param {Function|Promise} callable\n   * @param {*=} config\n   * @returns {Promise<[*, unknown] | [undefined, *]>}\n   */\n  static outcome = ofOutcome;\n}\n\nexport { Of, of, ofAny, ofAnyCase, ofCase, ofError, ofIt, ofOutcome, ofResult, ofSync };\n"],"names":["ERR_UNKNOWN","of","promise","Promise","resolve","then","result","catch","caughtError","Error","undefined","ofAny","callable","args","defaultResult","overrideError","call","constructor","name","Object","prototype","toString","Array","isArray","reject","caughtFunctionError","gen","next","value","caughtGeneratorFunctionError","caughtGeneratorError","message","ofAnyCase","config","defaults","error","retries","timeout","Number","parseInt","isFinite","MAX_SAFE_INTEGER","race","_resolve","setTimeout","attempt","ofCase","ofError","ofIt","ofOutcome","ofResult","ofSync","isFunction","test","Function","Of"],"mappings":"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"}