function of(r,e={}){let t;switch(e&&"[object Object]"===Object.prototype.toString.call(e)||(e={}),r.constructor.name||Object.prototype.toString.call(r)){case"Promise":t=r,e.retries=0;break;case"AsyncFunction":t=r(...Array.isArray(e.args)?[...e.args]:[]);break;case"GeneratorFunction":t=new Promise((t,o)=>{const s=r(...Array.isArray(e.args)?[...e.args]:[]);try{t(s.next().value)}catch(r){o(r)}});break;case"[object Generator]":t=new Promise((e,t)=>{try{e(r.next().value)}catch(r){t(r)}});break;case"Function":t=new Promise((t,o)=>{try{t(r(...Array.isArray(e.args)?[...e.args]:[]))}catch(r){o(r)}});break;default:return[e.defaults?e.defaults:void 0,e.error?e.error:new Error("Unknown call type")]}{const r=Number.parseInt(e.timeout);Number.isFinite(r)&&r>0?e.timeout=r>Number.MAX_SAFE_INTEGER?Number.MAX_SAFE_INTEGER:r:e.timeout=void 0}return(e.timeout?Promise.race([Promise.resolve(t),new Promise((r,t)=>{setTimeout(()=>t(new Error(`Timeout: ${e.timeout}ms`)))})]):Promise.resolve(t)).then(r=>[r,void 0]).catch(t=>{{const r=Number.parseInt(e.retries);Number.isFinite(r)&&r>0?e.retries=r>Number.MAX_SAFE_INTEGER?Number.MAX_SAFE_INTEGER:r:e.retries=void 0}return e.retries&&(e.attempt=void 0===e.attempt?0:e.attempt+1,e.attempt<e.retries)?of(r,e):(null==t&&(t=new Error("Rejected")),e.error instanceof Error?t=e.error:"string"==typeof e.error&&(t.message=e.error),[e.defaults,t])})}export{of};
//# sourceMappingURL=of.mjs.map
