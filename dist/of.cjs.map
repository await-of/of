{"version":3,"file":"of.cjs","sources":["../src/const/error.js","../src/core/ofAny.js","../src/const/type.js","../src/core/ofAnyCase.js","../src/core/ofCase.js","../src/core/ofError.js","../src/core/ofIt.js","../src/core/of.js","../src/core/ofResult.js","../src/core/ofSync.js","../src/util/isFunction.js","../src/core/ofOutcome.js","../src/class/Of.js"],"sourcesContent":["export const ERR_UNKNOWN = \"Unknown Error\";\n","import { ERR_UNKNOWN } from \"../const/error.js\";\nimport { FUNC, FUNC_ASYNC, FUNC_GEN, OBJ_GEN, PROMISE } from \"../const/type.js\";\n\n/**\n * @name ofAny\n * @param {Function|Promise} callable\n * @param {[]=} args\n * @param {*=} defaultResult\n * @param {*=} overrideError\n * @returns {Promise<[*, unknown] | [undefined, *]>}\n */\nexport function ofAny(callable, args, defaultResult, overrideError) {\n  let call;\n  switch (callable.constructor.name || Object.prototype.toString.call(callable)) {\n    case PROMISE:\n      call = callable;\n      break;\n    case FUNC_ASYNC:\n      call = callable(...(Array.isArray(args) ? [...args] : []));\n      break;\n    case FUNC:\n      call = new Promise((resolve, reject) => {\n        try {\n          resolve(callable(...(Array.isArray(args) ? [...args] : [])));\n        } catch (caughtFunctionError) {\n          reject(caughtFunctionError);\n        }\n      });\n      break;\n    case FUNC_GEN:\n      call = new Promise((resolve, reject) => {\n        const gen = callable(...(Array.isArray(args) ? [...args] : []));\n        try {\n          resolve(gen.next().value);\n        } catch (caughtGeneratorFunctionError) {\n          reject(caughtGeneratorFunctionError);\n        }\n      });\n      break;\n    case OBJ_GEN:\n      call = new Promise((resolve, reject) => {\n        try {\n          resolve(callable.next().value);\n        } catch (caughtGeneratorError) {\n          reject(caughtGeneratorError);\n        }\n      });\n      break;\n    default:\n      call = new Promise((resolve, reject) => {\n        Promise.resolve(callable).then(resolve).catch(reject);\n      });\n  }\n  return Promise.resolve(call)\n    .then((result) => [result])\n    .catch((caughtError) => {\n      if (caughtError === undefined || caughtError === null) {\n        caughtError = new Error(ERR_UNKNOWN);\n      }\n      if (overrideError instanceof Error) {\n        caughtError = overrideError;\n      } else if (typeof overrideError === \"string\") {\n        caughtError.message = overrideError;\n      }\n      return [defaultResult, caughtError];\n    });\n}\n","export const FUNC = \"Function\";\nexport const FUNC_ASYNC = \"AsyncFunction\";\nexport const FUNC_GEN = \"GeneratorFunction\";\nexport const OBJ_GEN = \"[object Generator]\";\nexport const PROMISE = \"Promise\";\n","import { ERR_UNKNOWN } from \"../const/error.js\";\nimport { FUNC, FUNC_ASYNC, FUNC_GEN, OBJ_GEN, PROMISE } from \"../const/type.js\";\n\n/**\n * @name ofAnyCase\n * @param {Function|Promise} callable\n * @param {*=} config\n * @returns {Promise<[*, unknown] | [undefined, *]>}\n */\nexport function ofAnyCase(callable, config = {}) {\n  {\n    const { args, defaults, error, retries, timeout } = new Object(config);\n    config = { args, defaults, error, retries, timeout };\n  }\n  let call;\n  switch (callable.constructor.name || Object.prototype.toString.call(callable)) {\n    case PROMISE:\n      call = callable;\n      config.retries = 0;\n      delete config.args;\n      break;\n    case FUNC_ASYNC:\n      call = callable(...(Array.isArray(config.args) ? [...config.args] : []));\n      break;\n    case FUNC:\n      call = new Promise((resolve, reject) => {\n        try {\n          resolve(callable(...(Array.isArray(config.args) ? [...config.args] : [])));\n        } catch (caughtFunctionError) {\n          reject(caughtFunctionError);\n        }\n      });\n      break;\n    case FUNC_GEN:\n      call = new Promise((resolve, reject) => {\n        const gen = callable(...(Array.isArray(config.args) ? [...config.args] : []));\n        try {\n          resolve(gen.next().value);\n        } catch (caughtGeneratorFunctionError) {\n          reject(caughtGeneratorFunctionError);\n        }\n      });\n      break;\n    case OBJ_GEN:\n      call = new Promise((resolve, reject) => {\n        try {\n          resolve(callable.next().value);\n        } catch (caughtGeneratorError) {\n          reject(caughtGeneratorError);\n        }\n      });\n      delete config.args;\n      break;\n    default:\n      call = new Promise((resolve, reject) => {\n        Promise.resolve(callable).then(resolve).catch(reject);\n      });\n      delete config.args;\n  }\n  if (config.timeout !== undefined) {\n    const timeout = Number.parseInt(`${config.timeout}`);\n    if (Number.isFinite(timeout) && timeout > 0) {\n      config.timeout = timeout > Number.MAX_SAFE_INTEGER ? Number.MAX_SAFE_INTEGER : timeout;\n    } else {\n      delete config.timeout;\n    }\n  } else {\n    delete config.timeout;\n  }\n  return (config.timeout\n    ? Promise.race([\n        Promise.resolve(call),\n        new Promise((_resolve, reject) => {\n          setTimeout(() => reject(new Error(`Timeout: ${config.timeout}ms`)));\n        }),\n      ])\n    : Promise.resolve(call)\n  )\n    .then((result) => [result])\n    .catch((caughtError) => {\n      if (config.retries !== undefined) {\n        const retries = Number.parseInt(config.retries);\n        if (Number.isFinite(retries) && retries > 0) {\n          config.retries = retries > Number.MAX_SAFE_INTEGER ? Number.MAX_SAFE_INTEGER : retries;\n        } else {\n          delete config.retries;\n        }\n      } else {\n        delete config.retries;\n      }\n      if (config.retries) {\n        config.attempt = config.attempt === undefined ? 0 : config.attempt + 1;\n        if (config.attempt < config.retries) {\n          return ofAnyCase(callable, config);\n        }\n      }\n      if (caughtError === undefined || caughtError === null) {\n        caughtError = new Error(ERR_UNKNOWN);\n      }\n      if (config.error instanceof Error) {\n        caughtError = config.error;\n      } else if (typeof config.error === \"string\") {\n        caughtError.message = config.error;\n      }\n      return [config.defaults, caughtError];\n    });\n}\n","import { ERR_UNKNOWN } from \"../const/error.js\";\n\n/**\n * @name ofCase\n * @param {Promise} promise\n * @param {*=} config\n * @returns {Promise<[*, unknown] | [undefined, *]>}\n */\nexport function ofCase(promise, config = {}) {\n  {\n    const { args, defaults, error, timeout } = new Object(config);\n    config = { args, defaults, error, timeout };\n  }\n  if (config.timeout !== undefined) {\n    const timeout = Number.parseInt(`${config.timeout}`);\n    if (Number.isFinite(timeout) && timeout > 0) {\n      config.timeout = timeout > Number.MAX_SAFE_INTEGER ? Number.MAX_SAFE_INTEGER : timeout;\n    } else {\n      delete config.timeout;\n    }\n  } else {\n    delete config.timeout;\n  }\n  return (config.timeout\n    ? Promise.race([\n        Promise.resolve(promise),\n        new Promise((_resolve, reject) => {\n          setTimeout(() => reject(new Error(`Timeout: ${config.timeout}ms`)));\n        }),\n      ])\n    : Promise.resolve(promise)\n  )\n    .then((result) => [result, undefined])\n    .catch((caughtError) => {\n      if (caughtError === undefined || caughtError === null) {\n        caughtError = new Error(ERR_UNKNOWN);\n      }\n      if (config.error instanceof Error) {\n        caughtError = config.error;\n      } else if (typeof config.error === \"string\") {\n        caughtError.message = config.error;\n      }\n      return [config.defaults, caughtError];\n    });\n}\n","import { ERR_UNKNOWN } from \"../const/error.js\";\n\n/**\n * @name ofError\n * @param {Promise} promise\n * @param {*=} overrideError\n * @returns {Promise<*>}\n */\nexport function ofError(promise, overrideError) {\n  return Promise.resolve(promise)\n    .then(() => undefined)\n    .catch((caughtError) => {\n      if (caughtError === undefined || caughtError === null) {\n        caughtError = new Error(ERR_UNKNOWN);\n      }\n      if (overrideError instanceof Error) {\n        caughtError = overrideError;\n      } else if (typeof overrideError === \"string\") {\n        caughtError.message = overrideError;\n      }\n      return caughtError;\n    });\n}\n","import { ERR_UNKNOWN } from \"../const/error.js\";\n\n/**\n * @name ofIt\n * @param {Promise} promise\n * @param {*=} defaultResult\n * @param {*=} overrideError\n * @returns {Promise<[*, unknown] | [undefined, *]>}\n */\nexport function ofIt(promise, defaultResult, overrideError) {\n  return Promise.resolve(promise)\n    .then((result) => [result])\n    .catch((caughtError) => {\n      if (caughtError === undefined || caughtError === null) {\n        caughtError = new Error(ERR_UNKNOWN);\n      }\n      if (overrideError instanceof Error) {\n        caughtError = overrideError;\n      } else if (typeof overrideError === \"string\") {\n        caughtError.message = overrideError;\n      }\n      return [defaultResult, caughtError];\n    });\n}\n","import { ERR_UNKNOWN } from \"../const/error.js\";\n\n/**\n * @name of\n * @param {Promise} promise\n * @returns {Promise<[*, unknown] | [undefined, *]>}\n */\nexport function of(promise) {\n  return Promise.resolve(promise)\n    .then((result) => [result])\n    .catch((caughtError) => {\n      if (caughtError === undefined || caughtError === null) {\n        caughtError = new Error(ERR_UNKNOWN);\n      }\n      return [undefined, caughtError];\n    });\n}\n","/**\n * @name ofResult\n * @param {Promise} promise\n * @param {*=} defaultResult\n * @returns {Promise<*>}\n */\nexport function ofResult(promise, defaultResult) {\n  return Promise.resolve(promise)\n    .then((result) => result)\n    .catch(() => defaultResult);\n}\n","import { ERR_UNKNOWN } from \"../const/error.js\";\n\nimport { isFunction } from \"../util/isFunction.js\";\n\n/**\n * @name ofSync\n * @param {Function} callable\n * @param {[]=} args\n * @param {*=} defaultResult\n * @param {*=} overrideError\n * @returns {[*, unknown] | [undefined, *]}\n */\nexport function ofSync(callable, args, defaultResult, overrideError) {\n  if (!isFunction(callable)) {\n    return [undefined, new Error(ERR_UNKNOWN)];\n  }\n  try {\n    return [callable(...(Array.isArray(args) ? [...args] : [])), undefined];\n  } catch (caughtFunctionError) {\n    let caughtError;\n    if (overrideError instanceof Error) {\n      caughtError = overrideError;\n    } else if (typeof overrideError === \"string\") {\n      caughtFunctionError.message = overrideError;\n      caughtError = caughtFunctionError;\n    } else if (caughtFunctionError === undefined || caughtFunctionError === null) {\n      caughtError = new Error(ERR_UNKNOWN);\n    } else {\n      caughtError = caughtFunctionError;\n    }\n    return [defaultResult, caughtError];\n  }\n}\n","/**\n * @param {*} value\n * @returns {boolean}\n */\nexport function isFunction(value) {\n  if (Object.prototype.toString.call(value) !== \"[object Function]\") {\n    return false;\n  }\n  return !/^class\\s/.test(Function.prototype.toString.call(value));\n}\n","import { ofAnyCase } from \"./ofAnyCase.js\";\n\n/**\n * @name ofOutcome\n * @description Returns result or thrown error wherever happens\n * @param {Function|Promise} callable\n * @param {*=} config\n * @returns {Promise<*>}\n */\nexport function ofOutcome(callable, config = {}) {\n  return new Promise((resolve) =>\n    ofAnyCase(callable, config).then(([result, error]) => {\n      resolve(error ? error : result);\n    }),\n  );\n}\n","import { ofAny } from \"../core/ofAny.js\";\nimport { ofAnyCase } from \"../core/ofAnyCase.js\";\nimport { ofCase } from \"../core/ofCase.js\";\nimport { ofError } from \"../core/ofError.js\";\nimport { ofIt } from \"../core/ofIt.js\";\nimport { of } from \"../core/of.js\";\nimport { ofResult } from \"../core/ofResult.js\";\nimport { ofSync } from \"../core/ofSync.js\";\nimport { ofOutcome } from \"../core/ofOutcome.js\";\n\nclass Of {\n  /**\n   * @name any\n   * @alias ofAny\n   * @public\n   * @static\n   * @method\n   * @param {Function|Promise} callable\n   * @param {[]=} args\n   * @param {*=} defaultResult\n   * @param {*=} overrideError\n   * @returns {Promise<[*, unknown] | [undefined, *]>}\n   */\n  static any = ofAny;\n  /**\n   * @name anyCase\n   * @alias ofAnyCase\n   * @public\n   * @static\n   * @method\n   * @param {Function|Promise} callable\n   * @param {*=} config\n   * @returns {Promise<[*, unknown] | [undefined, *]>}\n   */\n  static anyCase = ofAnyCase;\n  /**\n   * @name case\n   * @alias ofCase\n   * @public\n   * @static\n   * @method\n   * @param {Promise} promise\n   * @param {*=} config\n   * @returns {Promise<[*, unknown] | [undefined, *]>}\n   */\n  static case = ofCase;\n  /**\n   * @name error\n   * @alias ofError\n   * @public\n   * @static\n   * @method\n   * @param {Promise} promise\n   * @param {*=} overrideError\n   * @returns {Promise<*>}\n   */\n  static error = ofError;\n  /**\n   * @name it\n   * @alias ofIt\n   * @public\n   * @static\n   * @method\n   * @param {Promise} promise\n   * @param {*=} defaultResult\n   * @param {*=} overrideError\n   * @returns {Promise<[*, unknown] | [undefined, *]>}\n   */\n  static it = ofIt;\n  /**\n   * @name async\n   * @alias of\n   * @public\n   * @static\n   * @method\n   * @param {Promise} promise\n   * @returns {Promise<[*, unknown] | [undefined, *]>}\n   */\n  static async = of;\n  /**\n   * @name result\n   * @alias ofResult\n   * @public\n   * @static\n   * @method\n   * @param {Promise} promise\n   * @param {*=} defaultResult\n   * @returns {Promise<*>}\n   */\n  static result = ofResult;\n  /**\n   * @name sync\n   * @alias ofSync\n   * @public\n   * @static\n   * @method\n   * @param {Function} callable\n   * @param {[]=} args\n   * @param {*=} defaultResult\n   * @param {*=} overrideError\n   * @returns {[*, unknown] | [undefined, *]}\n   */\n  static sync = ofSync;\n  /**\n   * @name outcome\n   * @alias ofOutcome\n   * @public\n   * @static\n   * @method\n   * @param {Function|Promise} callable\n   * @param {*=} config\n   * @returns {Promise<[*, unknown] | [undefined, *]>}\n   */\n  static outcome = ofOutcome;\n}\n\nexport { Of };\n"],"names":["ERR_UNKNOWN","ofAny","callable","args","defaultResult","overrideError","call","constructor","name","Object","prototype","toString","Array","isArray","Promise","resolve","reject","caughtFunctionError","gen","next","value","caughtGeneratorFunctionError","caughtGeneratorError","then","catch","result","caughtError","Error","message","ofAnyCase","config","defaults","error","retries","timeout","undefined","Number","parseInt","isFinite","MAX_SAFE_INTEGER","race","_resolve","setTimeout","attempt","ofCase","promise","ofError","ofIt","of","ofResult","ofSync","isFunction","test","Function","ofOutcome","Of"],"mappings":"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"}