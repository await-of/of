function of(e){return Promise.resolve(e).then(e=>[e]).catch(e=>(null==e&&(e=new Error("Unknown Error")),[void 0,e]))}function ofAny(e,r,t,o){let s;switch(e.constructor.name||Object.prototype.toString.call(e)){case"Promise":s=e;break;case"AsyncFunction":s=e(...Array.isArray(r)?[...r]:[]);break;case"Function":s=new Promise((t,o)=>{try{t(e(...Array.isArray(r)?[...r]:[]))}catch(e){o(e)}});break;case"GeneratorFunction":s=new Promise((t,o)=>{const s=e(...Array.isArray(r)?[...r]:[]);try{t(s.next().value)}catch(e){o(e)}});break;case"[object Generator]":s=new Promise((r,t)=>{try{r(e.next().value)}catch(e){t(e)}});break;default:s=new Promise((r,t)=>{Promise.resolve(e).then(r).catch(t)})}return Promise.resolve(s).then(e=>[e]).catch(e=>(null==e&&(e=new Error("Unknown Error")),o instanceof Error?e=o:"string"==typeof o&&(e.message=o),[t,e]))}function ofAnyCase(e,r={}){{const{args:e,defaults:t,error:o,retries:s,timeout:n}=new Object(r);r={args:e,defaults:t,error:o,retries:s,timeout:n}}let t;switch(e.constructor.name||Object.prototype.toString.call(e)){case"Promise":t=e,r.retries=0,delete r.args;break;case"AsyncFunction":t=e(...Array.isArray(r.args)?[...r.args]:[]);break;case"Function":t=new Promise((t,o)=>{try{t(e(...Array.isArray(r.args)?[...r.args]:[]))}catch(e){o(e)}});break;case"GeneratorFunction":t=new Promise((t,o)=>{const s=e(...Array.isArray(r.args)?[...r.args]:[]);try{t(s.next().value)}catch(e){o(e)}});break;case"[object Generator]":t=new Promise((r,t)=>{try{r(e.next().value)}catch(e){t(e)}}),delete r.args;break;default:t=new Promise((r,t)=>{Promise.resolve(e).then(r).catch(t)}),delete r.args}if(void 0!==r.timeout){const e=Number.parseInt(r.timeout);Number.isFinite(e)&&e>0?r.timeout=e>Number.MAX_SAFE_INTEGER?Number.MAX_SAFE_INTEGER:e:delete r.timeout}else delete r.timeout;return(r.timeout?Promise.race([Promise.resolve(t),new Promise((e,t)=>{setTimeout(()=>t(new Error(`Timeout: ${r.timeout}ms`)))})]):Promise.resolve(t)).then(e=>[e]).catch(t=>{if(void 0!==r.retries){const e=Number.parseInt(r.retries);Number.isFinite(e)&&e>0?r.retries=e>Number.MAX_SAFE_INTEGER?Number.MAX_SAFE_INTEGER:e:delete r.retries}else delete r.retries;return r.retries&&(r.attempt=void 0===r.attempt?0:r.attempt+1,r.attempt<r.retries)?ofAnyCase(e,r):(null==t&&(t=new Error("Unknown Error")),r.error instanceof Error?t=r.error:"string"==typeof r.error&&(t.message=r.error),[r.defaults,t])})}function ofCase(e,r={}){{const{args:e,defaults:t,error:o,timeout:s}=new Object(r);r={args:e,defaults:t,error:o,timeout:s}}if(void 0!==r.timeout){const e=Number.parseInt(r.timeout);Number.isFinite(e)&&e>0?r.timeout=e>Number.MAX_SAFE_INTEGER?Number.MAX_SAFE_INTEGER:e:delete r.timeout}else delete r.timeout;return(r.timeout?Promise.race([Promise.resolve(e),new Promise((e,t)=>{setTimeout(()=>t(new Error(`Timeout: ${r.timeout}ms`)))})]):Promise.resolve(e)).then(e=>[e,void 0]).catch(e=>(null==e&&(e=new Error("Unknown Error")),r.error instanceof Error?e=r.error:"string"==typeof r.error&&(e.message=r.error),[r.defaults,e]))}function ofIt(e,r,t){return Promise.resolve(e).then(e=>[e]).catch(e=>(null==e&&(e=new Error("Unknown Error")),t instanceof Error?e=t:"string"==typeof t&&(e.message=t),[r,e]))}function ofResult(e,r){return Promise.resolve(e).then(e=>e).catch(()=>r)}export{of,ofAny,ofAnyCase,ofCase,ofIt,ofResult};
//# sourceMappingURL=of.mjs.map
